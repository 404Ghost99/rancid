#! @EXPECT_PATH@ --
##
## $Id$
##
## @PACKAGE@ @VERSION@
@copyright@
# 
# Dell/EqualLogic hacks implemented by Frank Fegert <fra.nospam.nk@gmx.de>.
#
# eqllogin - Dell EqualLogic login
#

# Sometimes storage take awhile to answer (the default is 10 sec)
set timeoutdflt 45
# Some CLIs having problems if we write too fast (Extreme, PIX, Cat)
set send_human {.2 .1 .4 .2 1}

# Usage line
set usage "Usage: $argv0 \[-dhSV\] \[-m|M\] \[-c command\] \[-Evar=x\] \
\[-f cloginrc-file\] \ \[-p user-password\] \[-s script-file\] \[-t timeout\] \
\[-u username\] \[-x command-file\] \[-y ssh_cypher_type\] storage \[storage...\]\n"

# Password file
set password_file $env(HOME)/.cloginrc
# Default is to login to the storage
set do_command 0
set do_script 0
# The default is to look in the password file to find the passwords.  This
# tracks if we receive them on the command line.
set do_passwd 1
# cloginrc debugging knob
set do_cloginrcdbg 0
# Sometimes storage take awhile to answer (the default is 10 sec)
if {! [info exists timeoutdflt]} {
    set timeoutdflt 10
}
# intialize cloginrc parsing stacks
set int_file {}
set int_lineno {}

if {[info exists env(CLOGINRC)]} {
    set password_file $env(CLOGINRC)
}

# Process the command line
for {set i 0} {$i < $argc} {incr i} {
    set arg [lindex $argv $i]

    switch  -glob -- $arg {
	# Expect debug mode
	-d* {
	    exp_internal 1
	# Help
	} -h* {
	    send_user "$usage"
	    exit 0
	# Command to run.
	} -c* {
	    if {! [regexp .\[cC\](.+) $arg ignore command]} {
		incr i
		set command [lindex $argv $i]
	    }
	    set do_command 1
	# Environment variable to pass to -s scripts
	} -E* {
	    if {[regexp .\[E\](.+)=(.+) $arg ignore varname varvalue]} {
		set E$varname $varvalue
	    } else {
		send_user "\nError: invalid format for -E in $arg\n"
		exit 1
	    }
	# alternate cloginrc file
	} -f* {
	    if {! [regexp .\[fF\](.+) $arg ignore password_file]} {
		incr i
		set password_file [lindex $argv $i]
	    }
	# VTY Password
	} -p* {
	    if {! [regexp .\[pP\](.+) $arg ignore userpasswd]} {
		incr i
		set userpasswd [lindex $argv $i]
	    }
	    set do_passwd 0
	# cloginrc debugging knobs
	} -m* {
	    set do_cloginrcdbg 1
	} -M* {
	    set do_cloginrcdbg 2
	# Expect script to run.
	} -s* {
	    if {! [regexp .\[sS\](.+) $arg ignore sfile]} {
		incr i
		set sfile [lindex $argv $i]
	    }
	    if { ! [file readable $sfile] } {
		send_user "\nError: Can't read $sfile\n"
		exit 1
	    }
	    set do_script 1
	# Timeout
	} -t* {
	    if {! [regexp .\[tT\](.+) $arg ignore timeout]} {
		incr i
	        set timeoutdflt [lindex $argv $i]
	    }
	# Username
	} -u* {
	    if {! [regexp .\[uU\](.+) $arg ignore user]} {
		incr i
		set username [lindex $argv $i]
	    }
	# Version string
	} -V* {
	    send_user "rancid 3.5.1\n"
	    exit 0
	# 'ssh -c' cypher type
	} -y* {
	    if {! [regexp .\[eE\](.+) $arg ignore cypher]} {
		incr i
		set cypher [lindex $argv $i]
	    }
	# Command file
	} -x* {
	    if {! [regexp .\[xX\](.+) $arg ignore cmd_file]} {
		incr i
		set cmd_file [lindex $argv $i]
	    }
	    if [catch {set cmd_fd [open $cmd_file r]} reason] {
		send_user "\nError: $reason\n"
		exit 1
	    }
	    set cmd_text [read $cmd_fd]
	    close $cmd_fd
	    set command [join [split $cmd_text \n] \;]
	    set do_command 1
	} -* {
	    send_user "\nError: Unknown argument! $arg\n"
	    send_user $usage
	    exit 1
	} default {
	    break
	}
    }
}
# Process storage...no storage listed is an error.
if { $i == $argc } {
    send_user "\nError: $usage"
}

# Only be quiet if we are running a script (it can log its output
# on its own)
if { $do_script } {
    log_user 0
} else {
    log_user 1
}

#
# Done configuration/variable setting.  Now run with it...
#

# This is a helper function to make the password file easier to
# maintain.  Using this the password file has the form:
# add password sl*	pete cow
# add password at*	steve
# add password *	hanky-pie
proc add {var args} {
    global int_file int_lineno int_$var
    set file [lindex $int_file 0]
    set lineno [lindex $int_lineno 0]
    lappend int_$var "$var:$file:$lineno: $args"
}
proc include {args} {
    global env
    regsub -all "(^{|}$)" $args {} args
    if { [regexp "^/" $args ignore] == 0 } {
	set args $env(HOME)/$args
    }
    source_password_file $args
}

proc find {var router} {
    global do_cloginrcdbg
    upvar int_$var list
    if { [info exists list] } {
	foreach line $list {
	    if { [string match -nocase [lindex $line 1] $router] } {
		if { $do_cloginrcdbg > 0 } {
		    send_error -- [join [list [lindex $line 0] [lrange $line 1 end] "\r\n"]]
		}
		if { $do_cloginrcdbg == 2 } {
		    # save return value
		    if {! [info exists result]} {
			set result [lrange $line 2 end]
		    }
		} else {
		    return [lrange $line 2 end]
		}
	    }
	}
    }

    if { $do_cloginrcdbg == 2 } {
	if {[info exists result]} {
	    return $result
	}
    }
    return {}
}

# Loads the password file.  Note that as this file is tcl, and that
# it is sourced, the user better know what to put in there, as it
# could install more than just password info...  I will assume however,
# that a "bad guy" could just as easy put such code in the clogin
# script, so I will leave .cloginrc as just an extention of that script
proc source_password_file { file } {
    global env int_file int_lineno
    if { ! [file exists $file] } {
	send_user "\nError: password file ($file) does not exist\n"
	exit 1
    }
    file stat $file fileinfo
    if { [expr ($fileinfo(mode) & 007)] != 0000 } {
	send_user "\nError: $file must not be world readable/writable\n"
	exit 1
    }
    if [catch {set fd [open $file "r"]} reason] {
	send_user "\nError: $reason\n"
	exit 1
    }
    set int_file [linsert $int_file 0 $file]
    set int_lineno [linsert $int_lineno 0 0]
    while { [gets $fd line] >= 0 } {
	set tmp [lindex $int_lineno 0]; incr tmp
	lset int_lineno 0 $tmp
	eval $line
    }
    set int_file [lrange $int_file 1 end]
    set int_lineno [lrange $int_lineno 1 end]
    close $fd
}

# Log into the storage.
# returns: 0 on success, 1 on failure, -1 if rsh was used successfully
proc login { router user userpswd passwd cmethod cyphertype } {
    global command spawn_id in_proc do_command do_script
    global prompt prompt_match u_prompt p_prompt sshcmd
    set in_proc 1
    set uprompt_seen 0
    set login_log_seen 0

    # try each of the connection methods in $cmethod until one is successful
    set progs [llength $cmethod]
    foreach prog [lrange $cmethod 0 end] {
	incr progs -1
	if [string match "ssh*" $prog] {
	    # ssh to the storage & try to login with or without an identfile.
	    regexp {ssh(:([^[:space:]]+))*} $prog methcmd suffix port
	    set cmd $sshcmd
	    if {"$port" != ""} {
		set cmd "$cmd -p $port"
	    }
	    if {"$cyphertype" != ""} {
		set cmd "$cmd -c $cyphertype"
	    }
	    set retval [catch {eval spawn [split "$cmd -x -l $user $router" { }]} reason]
	    if { $retval } {
		send_user "\nError: $cmd failed: $reason\n"
		return 1
	    }
	} else {
	    send_user "\nError: unknown connection method: $prog\n"
	    return 1
	}
	sleep 0.3

	# This helps cleanup each expect clause.
	expect_after {
	    timeout {
		send_user "\nError: TIMEOUT reached\n"
		catch {close}; catch {wait};
		if { $in_proc} {
		    return 1
		} else {
		    continue
		}
	    } eof {
		send_user "\nError: EOF received\n"
		catch {close}; catch {wait};
		if { $in_proc} {
		    return 1
		} else {
		    continue
		}
	    }
	}

    expect {
	-re "(^Last login: .*|Welcome to Group Manager|Copyright \[0-9\]+.*)" {
	    exp_continue
	}
	-re "(Connection refused|Secure connection \[^\n\r]+ refused)" {
	    catch {close}; catch {wait};
	    if !$progs {
		send_user "\nError: Connection Refused ($prog): $router\n"
		return 1
	    }
	}
	-re "(Connection closed by|Connection to \[^\n\r]+ closed)" {
	    catch {close}; catch {wait};
	    if !$progs {
		send_user "\nError: Connection closed ($prog): $router\n"
		return 1
	    }
	}
	eof { send_user "\nError: Couldn't login: $router\n"; wait; return 1 }
	-nocase "unknown host\r" {
	    send_user "\nError: Unknown host $router\n";
	    catch {close}; catch {wait};
	    return 1
	}
	"Host is unreachable" {
	    send_user "\nError: Host Unreachable: $router\n";
	    catch {close}; catch {wait};
	    return 1
	}
	"No address associated with name" {
	    send_user "\nError: Unknown host $router\n";
	    catch {close}; catch {wait};
	    return 1
	}
	-re "(Host key not found |The authenticity of host .* be established).* \\(yes\/no\\)\\?" {
	    send "yes\r"
	    send_user "\nHost $router added to the list of known hosts.\n"
	    exp_continue
	}
	-re "HOST IDENTIFICATION HAS CHANGED.* \\(yes\/no\\)\\?" {
	    send "no\r"
	    send_user "\nError: The host key for $router has changed.  Update the SSH known_hosts file accordingly.\n"
	    catch {close}; catch {wait};
	    return 1
	}
	-re "HOST IDENTIFICATION HAS CHANGED\[^\n\r]+" {
	    send_user "\nError: The host key for $router has changed.  Update the SSH known_hosts file accordingly.\n"
	    return 1
	}
	-re "Offending key for .* \\(yes\/no\\)\\?" {
	    send "no\r"
	    send_user "\nError: host key mismatch for $router.  Update the SSH known_hosts file accordingly.\n"
	    catch {close}; catch {wait};
	    return 1
	}
	-nocase -re "^warning: remote host denied authentication agent forwarding." {
	    exp_continue;
	}
	-re "(denied|Sorry)" {
	    send_user "\nError: Check your passwd for $router\n"
	    catch {close}; catch {wait}; return 1
	}
	"Login failed" {
	    send_user "\nError: Check your passwd for $router\n"
	    catch {close}; catch {wait}; return 1
	}
	-re "% (Bad passwords|Authentication failed)" {
	    send_user "\nError: Check your passwd for $router\n"
	    catch {close}; catch {wait}; return 1
	}
	-re "@\[^\r\n]+ $p_prompt" {
	    # ssh pwd prompt
	    sleep 1
	    send -- "$userpswd\r"
	    exp_continue
	}
	-re "$u_prompt"	{
	    send -- "$user\r"
	    set uprompt_seen 1
	    exp_continue
	}
	-re "$p_prompt"	{
	    sleep 1
	    if {$uprompt_seen == 1} {
	          send -- "$userpswd\r"
	    } else {
	          send -- "$passwd\r"
	    }
	    exp_continue
	}
	-re "$prompt" {
	    set prompt_match $expect_out(0,string);
	    break;
	}
	"Login invalid"	{
	    send_user "\nError: Invalid login: $router\n";
	    catch {close}; catch {wait}; return 1
	}
	-re "\[^\r\n]*\[\r\n]+"	{ exp_continue; }
     }
    }

    set in_proc 0
    return 0
}

# Run commands given on the command line.
proc run_commands { prompt command } {
    set in_proc 1
    set reprompt $prompt

    # this is the only way i see to get rid of more prompts in o/p..grrrrr
    log_user 0

    # handle escaped ;s in commands, and ;; and ^;
    regsub -all {([^\\]);;} $command "\\1;\u002;" esccommand
    regsub {^;} $esccommand "\u002;" command
    set sep "\\1\u001"
    regsub -all {([^\\])\;} $command "$sep" esccommand
    set sep "\u001"
    set commands [split $esccommand $sep]
    set num_commands [llength $commands]
    
    for {set i 0} {$i < $num_commands} { incr i} {
	if { [lindex $commands $i] == "\u002" } {
	    send -- "\r"
	} else {
	    send -- "[subst -nocommands [lindex $commands $i]]\r"
	}
	expect {
	    -re "\b+"				{ exp_continue }
	    -re "^\[^\n\r *]*$reprompt"		{ send_user -- "$expect_out(buffer)"
						}
	    -re "^\[^\n\r]*$reprompt."		{ send_user -- "$expect_out(buffer)"
						  exp_continue
						}
	    -re "\[^\r\n]*\[\n\r]+"		{ send_user -- "$expect_out(buffer)"
						  exp_continue
						}
	}
    }
    log_user 1

    send -h "logout\r"
    expect {
	-re "^Do you really want to logout.*"   {
						  send -h "y\r"
						  exp_continue;
						}
	-re "\[\n\r]+"				{ exp_continue }
	timeout					{ catch {close}; catch {wait};
						  return 1
						}
	eof					{ return 0 }
    }
    set in_proc 0
}

#
# For each storage... (this is main loop)
#
source_password_file $password_file
set in_proc 0
set exitval 0
set prompt_match ""
foreach router [lrange $argv $i end] {
    set router [string tolower $router]

    # device timeout
    set timeout [find timeout $router]
    if { [llength $timeout] == 0 } {
	set timeout $timeoutdflt
    }

    # Default prompt.
    set prompt [join [find prompt $router] ""]
    if { [llength $prompt] == 0 } {
	set prompt ">"
    }

    # Figure out passwords
    if { $do_passwd } {
      set pswd [find password $router]
      if { [llength $pswd] == 0 } {
	send_user -- "\nError: no password for $router in $password_file.\n"
	continue
      }
      set passwd [join [lindex $pswd 0] ""]
    } else {
	set passwd $userpasswd
    }

    # Figure out username
    if {[info exists username]} {
      # command line username
      set ruser $username
    } else {
      set ruser [join [find user $router] ""]
      if { "$ruser" == "" } { set ruser $default_user }
    }

    # Figure out username's password
    if {[info exists userpasswd]} {
      # command line username
      set userpswd $userpasswd
    } else {
      set userpswd [join [find userpassword $router] ""]
      if { "$userpswd" == "" } { set userpswd $passwd }
    }

    # Figure out prompts
    set u_prompt [find userprompt $router]
    if { "$u_prompt" == "" } {
	set u_prompt "(\[Uu]sername|Login|login|user name|User):"
    } else {
	set u_prompt [join [lindex $u_prompt 0] ""]
    }
    set p_prompt [find passprompt $router]
    if { "$p_prompt" == "" } {
	set p_prompt "(\[Pp]assword|passwd|Enter password for \[^ :]+):"
    } else {
	set p_prompt [join [lindex $p_prompt 0] ""]
    }

    # Figure out cypher type
    if {[info exists cypher]} {
        # command line cypher type
        set cyphertype $cypher
    } else {
        set cyphertype [find cyphertype $router]
    }

    # Figure out connection method
    set cmethod [find method $router]
    if { "$cmethod" == "" } { set cmethod {{telnet} {ssh}} }

    # Figure out the SSH executable name
    set sshcmd [join [lindex [find sshcmd $router] 0] ""]
    if { "$sshcmd" == "" } { set sshcmd {ssh} }

    # if [-mM], skip do not login
    if { $do_cloginrcdbg > 0 } { continue; }

    # Login to the storage
    if {[login $router $ruser $userpswd $passwd $cmethod $cyphertype]} {
	incr exitval
	# if login failed or ssh was unsuccessful, move on to the next device
	continue
    }

    # we are logged in, now figure out the full prompt
    send "\r"
    regsub -all {^(\^*)(.*)} $prompt {\2} reprompt
    expect {
	-re "\[\r\n]+"		{ exp_continue; }
	-re "^(.+\[:.])1 ($reprompt)" { # stoopid extreme cmd-line numbers and
				  # prompt based on state of config changes,
				  # which may have an * at the beginning.
				  set junk $expect_out(1,string)
				  regsub -all "^\\\* " $expect_out(1,string) {} junk
				  regsub -all "\[\]\[\(\)]" $junk {\\&} junk;
				  set prompt ".? ?$junk\[0-9]+ $expect_out(2,string)";
				}
	-re "^.+$reprompt"	{ set junk $expect_out(0,string);
				  regsub -all "\[\]\[\(\)+]" $junk {\\&} prompt;
				}
    }
    if { $do_command || $do_script } {
	send -h "cli-settings paging off\r"
	send -h "stty hardwrap off\r"
	send -h "stty columns 255\r"
	expect -re $prompt		{}
    }
    if { $do_command } {
	if {[run_commands $prompt $command]} {
	    incr exitval
	    continue
	}
    } elseif { $do_script } {
	source $sfile
	catch {close};
    } else {
	log_user 1
	interact
    }

    # End of for each storage
    catch {wait};
    sleep 0.3
}
exit $exitval
